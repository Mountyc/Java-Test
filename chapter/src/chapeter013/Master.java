package chapeter013;

//主人类
public class Master {
    /*
    //假设主人起初的时候只喜欢养宠物狗狗
    //喂养宠物狗狗
    public void feed(Dog d){
        d.eat();
    }

    //由于新的需求产生，导致我们“不得不”“去修改Master这个类的代码
    public void feed(Cat c){
        c.eat();
    }
     */

    //能不能让Master主人这个类以后不在修改了
    //即使主人又喜欢养其他的宠物了，Master也不需要修改。
    //这个时候就需要使用：多态机制。
    //最好不要写具体的宠物类型，这样会影响程序的扩展性。
    public void feed (Pet pet){
        //编译的时候，编译器发现pet是Pet类，会去Pet类中去找eat（）方法，结果找到了，编译通过
        //运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat（）方法上。
        //这就多态的使用。
        pet.eat();
    }
}
/*
    注意这里的分析:
        主人起初的时候只喜欢养宠物狗狗
        随着时间的推移，主人又喜欢上养"猫咪"
        在实际的开发中这就表示客户产生了新的需求。作为软件的开发人员来说，必须满足客户的需求。我们怎么去满足客户的需求呢?
        在不使用多态机制的前提下，目前我们只能在Master类中添加一个新的方法。

    思考:软件在扩展新需求过程当中，修改Master这个类有什么问题?
        一定要记住:软件在扩展过程当中，修改的越少越好。
        修改的越多，你的系统当前的稳定性就越差，未知的风险就越多。

        其实这里涉及到一个软件的开发原则:
            软件开发原则有七大原则(不属于java，这个开发原则属于整个软件业):
                其中有一条最基本的原则:OCP(开闭原则)
    什么是开闭原则?
        对扩展开放(你可以额外添加，没问题)，对修改关闭(最好很少的修改现有程序)
        在软件的扩展过程当中，修改的越少越好。

    高手开发项目不是仅仅为了实现客户的需求，还需要考虑软件的扩展性。

    什么是软件扩展性?
        假设电脑中的内存条部件坏了，我们可以买一个新的插上，直接使用。
        这个电脑的设计就考虑了"扩展性"。内存条的扩展性很好。

    面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。
    因为面向具体编程会让软件的扩展力很差。
 */
